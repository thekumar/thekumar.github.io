---
layout: post
title: Sync-o de Mayo!
date: '2018-05-04T02:32:35-07:00'
tags:
- ot
- operational transforms
- collaboration
- real-time
- sync
- software design
- software architecture
tumblr_url: https://blog.vijayarunkumar.com/post/173569405583/sync-o-de-mayo
---
<p>I know it’s not May 5th yet. But, I don’t have enough Star Wars geek cred to pull off a “May the fourth be with you!” related pun. So, please bear with me.</p><p>Previously, I mentioned how the two magical words, “Operational Transforms,” a.k.a. “OT”, were the solution to all of my real-time syncing woes. So, what is OT? Before answering that, let’s first take a look at the problem we face with syncing.</p><p>Consider the scenario where two people, A and B, are simultaneously editing a simple document containing the text “hello!” initially.</p><ul><li>The initial state of the document contains the text “hello!” at Version 0.</li><li>Person A makes an edit replacing the ‘h’ with a capital ‘H’ so that the document now says “Hello!” at their Version 1.<br/></li><li>Person B makes an edit inserting the text “ world” before the ‘!’ to make it say “hello world!” at their  Version 1.</li></ul><p>Now each person has arrived at a different state of the document, and we want to be able to merge their changes together to converge the divergent states back to a version of the document that contains both edits and says “Hello world!”</p><p>There is nothing new about this. We deal with this almost everyday in today’s workplace whether you are a developer merging changes in Git, or a product manager merging different versions of a Powerpoint slideshow, or a lawyer merging suggestions in a contract using Track Changes, or simply keeping your Dropbox / Google Drive in sync with your local folder. And regardless of what scenario you are dealing with, the solution is pretty much the same.</p><p>Diff, Sync, Merge.</p><p>You diff your version of the document, as well as the version that you want to sync with, against a common ancestor version from history to determine what exactly changed, and then determine how to merge both your changes. Finally, you sync the merged document back to the repository.</p><h2>The Problem with Diff/Sync/Merge</h2><p>Diff Sync Merge (aka Diff Merge) is a solid and proven way to perform merges, but it comes with one huge caveat. It needs multiple versions of the entire model to be retrieved/synced for performing sync and merge operations. Whether it was just a single character that was replaced, or the entire document, you still need access to the entire document to perform the diffs. This works well for use cases where you only have to sync relatively rarely.</p><p>But, if you want to build a real-time collaborative application a la Google Docs, the latency involved in pushing/retrieving entire document models back and forth on each individual edit would make it unusable. We need to rethink syncing and merging. <b><i>We need a way to sync changes without syncing entire documents.</i></b></p><h2>OT to the Rescue!</h2><p>The basic premise behind operation transform is quite simple, and can be explained with the following diamond.</p><figure data-orig-width="761" data-orig-height="499" class="tmblr-full"><img src="https://64.media.tumblr.com/e35ec154904168812532f8583e6bec75/05b21657a293aedb-99/s540x810/a650a01f996ed5d8569234f65add581010987adf.png" alt="image" data-orig-width="761" data-orig-height="499"/></figure><!-- more --><p>You start at an initial model state m0. Client A performs an Operation A and arrives at model state mA. Client B simultaneously performs Operation B to arrive at model state mB. Now, given the pair of operations A and B, we need to find complimentary operations A’ and B’ such that mB + A’, and mA + B’ both converge back to a single model that both clients can sync back to. For example, Client A’s operation of inserting ‘!’ at the 5th index-0 position get’s transformed to inserting ‘!’ at the 4th index-0 position, after B’s operation of deleting the first character is performed. And B’s operation undergoes no transformation because A’s operation doesn’t affect it’s index.</p><p>The important thing to note here is that regardless of what the model was, those two operations will lead to the same exact transformed operation. For instance, if the initial model state was “namaste”, and we performed the same operations as above. We would arrive at the same synced state of “amas!te”.</p><p><b><i>If we can define transformations A’ and B’ for every possible pair of operations A and B, then we can achieve our goal of syncing changes without syncing documents.</i></b></p><p>Of course, figuring out the <i><b>useful </b></i>transformations for all the different combinations of A and B could get quite complicated, but once they’ve been figured out, OT will guarantee that the clients will arrive at a synced state.</p><p>I emphasize “useful” because one could easily define A’ and B’ to simply delete the entire model for any and all combinations of A and B. In that case, your clients would technically arrive at a synced state and satisfy OT’s requirements. But it would be an empty document, and that does nobody any good :/</p><p>So, let’s take our initial example of taking the string “hello!”, and the two clients A and B, with A replacing ‘h’ with ‘H’, and B inserting “ world” before the exclamation mark. These state changes and all other text manipulation can be achieved via a minimal set of 2 operations:</p><p>1. deleteCharacter(atPosition p) aka DELETE (index)<br/>2. insertCharacter(character c, atPosition p) aka INSERT (char, index)</p><p>This implies there are 4 possible pairs of inputs for our OT diamond.</p><ol><li>DELETE / DELETE<br/></li><li>DELETE / INSERT</li><li>INSERT / DELETE<br/></li><li>INSERT / INSERT<br/></li></ol><p>And we could define our transformation logic as follows:</p><table style="border: solid 1px black; border-collapse: collapse;"><tr style="background-color: #999999;"><td>Operation A</td>
  <td>Operation B</td>
  <td>Transform A&rsquo;</td>
  <td>Transform B&rsquo;</td>
</tr><tr><td>DELETE (indexA)</td>
  <td>DELETE (indexB)</td>
  <td>(indexB == indexA) ? NO_OP : (indexB &lt; indexA) ? DELETE(indexA - 1) : DELETE(indexA)</td>
  <td>(indexB == indexA) ? NO_OP : (indexA &lt; indexB) ? DELETE(indexB - 1) : DELETE(indexB)</td>
</tr><tr><td>INSERT (charA, indexA)</td>
  <td>DELETE (indexB)</td>
  <td>(index B &lt; indexA) ? INSERT(charA, indexA - 1) : INSERT(charA, indexA)</td>
  <td>(index A &lt;= indexB) ? DELETE(indexB + 1) : DELETE(indexB)&lt;/td&gt;
</td></tr><tr><td>DELETE (indexA)</td>
  <td>INSERT (charB, indexB)</td>
  <td>(index B &lt;= indexA) ? DELETE(indexA + 1) : DELETE(indexA)&lt;/td&gt;
  </td><td>(index A &lt; indexB) ? INSERT(charB, indexB - 1) : INSERT(charB, indexB)</td>
</tr><tr><td>INSERT (charA, indexA)</td>
  <td>INSERT (charB, indexB)</td>
  <td>(index A &gt; indexB) ? INSERT(charA, indexA + 1) : INSERT(charA, indexA)</td>
  <td>(index B &gt;= indexA) ? INSERT(charB, indexB + 1) : INSERT(charB, indexB)</td>
</tr></table><p>
There are a couple of interesting things to notice with the transforms we have defined.
</p><ul><li>First, we defined a new NO_OP operation to return for the case where both clients perform the same delete operation. This is to avoid double-deleting the wrong character.</li><li>And second, the &gt;= in the last pair prioritize A&rsquo;s inserts over B&rsquo;s insert if they both insert characters at the same index. So if A inserted &ldquo; Bob&rdquo; and B inserted &ldquo; World&rdquo;, the output will always result in &ldquo; Bob World&rdquo;. <ul><li>Note: If both added &ldquo; World&rdquo;, we would end up with &ldquo; World World&rdquo;, but in a real-time collaborative environment, this is acceptable. If we really care about avoiding duplicates, we could define higher level operations that look at word inserts and compare whole words/phrases for duplicates.</li></ul></li></ul><p>
This transformation model works well for single character operation. But how do we handle a string of operations by each client? For instance, replacing &lsquo;h&rsquo; with 'H&rsquo; itself takes a minimum of two operations (a DELETE followed by an INSERT) and inserting &ldquo; world&rdquo; requires 6 INSERT operations.
</p><h2>Handling Multiple Operations</h2><p>Once you’ve figured out the transformation logic for a single pair of operations, handling multiple operations becomes a no-brainer. It’s simply the same OT diamond cascading transformed operations as input to the next OT diamond.</p><p>Take the following example where A diverges by 3 operations, while B diverges by 2. To compute the transformed operations A1′, A2′, and A3′ to apply on client B, as well as B1′ and B2′ to apply on client A, you simply have to cascade your transformations down. Note that there are intermediate states and intermediate operations shown in the diagram below, but there is no need to store or even care about the intermediate models as OT works independent of model state as shown above with that really lame “amas!te” example :)</p><figure data-orig-width="803" data-orig-height="812" class="tmblr-full"><img src="https://64.media.tumblr.com/68a75fa36e6e99da7ec14f0ddcfa2a25/05b21657a293aedb-f5/s540x810/42107c1541e5f7ca9c5bfa795897c3d142a3e9a0.png" alt="image" data-orig-width="803" data-orig-height="812"/></figure><p>In the above case, we had to perform transformations on 6 different OT diamonds. Basically, OT becomes a O(m*n) operation, where m &amp; n are the number of operations the clients have diverged by. So, it is preferable to sync frequently keeping the count of operations to perform OT on pretty low.</p><p>Luckily, this suits really well for real-time collaborative use cases where we are syncing almost continuously after each and every edit.</p><h2>Handling Multiple Clients</h2><p>Syncing multiple clients is just as easy. We simply sync them sequentially and additively. Assume that you have 3 clients A, B, and C that have each performed 3, 2, and 2 operations respectively. To bring them all in sync, we first sync A (operations A1, A2, and A3) and B (B1 and B2) to determine A’ (A1′, A2′, A3′) and B’ (B1′, B2′). Now both A + B’ and B + A’ lead to the same synced state mAB for both clients.</p><p>We can now take one of these equivalent paths (either A1, A2, A3, B1′, B2′ or B1, B2, A1′, A2′, A3′), and sync that with C to determine C1′ and C2′, as well as the transformed operations to apply on client C. Let’s take the first path A1, A2, A3, B1′, B2′ for illustrating how this works. The sync would work as shown in the following diagram.</p><figure data-orig-width="1152" data-orig-height="864" class="tmblr-full"><img src="https://64.media.tumblr.com/d85a5c54b0f0ba3548f0d4122ac2791a/05b21657a293aedb-21/s540x810/3af9259e46797a1c72965dddd67ca5ddbd23639b.png" alt="image" data-orig-width="1152" data-orig-height="864"/></figure><p>It’s not shown clearly in the diagram, but C1′ and C2′ are operations that get applied on both A and B, which are currently both at state mAB, to bring all three clients to the same synced state mABC. And we can follow this same technique and extend it to as many clients as we need to sync.</p><p>That was just a brief intro to Operational Transformations which forms the basis for real-time collaborative tools such as Google Docs, Dropbox Paper, and Apple iWork. Hopefully, it made sense, and you got to learn something new.</p>
